---
title: "Sexual selection and the population genetics of a selfish gene"  
author: "Thomas A Keaney, Therésa M Jones and Luke Holman"
subtitle: Supplementary material
output:
  pdf_document:
    toc: no
    number_sections: no
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, cache = FALSE, warning = FALSE, message = FALSE, fig.align = "center")
```

Click **[here](https://tomkeaney.github.io/SD_sexual_selection/)** to view the HTML report, which serves as online supplementary material for the associated manuscript (http://dx.doi.org/10.1098/rspb.2021.1190), published in _Proceedings of the Royal Society B_. The report is split into three parts. The first provides the supplementary methods, the second documents our empirical analysis (you can find raw data here) and the third provides an in-depth explanation for how we coded our population genetic model. Together, the report includes all supplementary figures and tables, the R script required to produce the analysis, figures and tables, and the raw data.

In an attempt to future proof the availability of our supplementary material, we also include the supplementary methods, Table S1-2 and Figures S1-8 in this document. Additionally, our data will be deposited in the Dryad database **[here](https://doi.org/10.5061/dryad.pzgmsbcmt)**.

```{r, include=FALSE}
library(png) # to load images
library(grid) # to plot images
library(tidyverse) # for data wrangling and plotting
library(reshape2) # for the melt function
library(brms) # for Bayesian models
library(tidybayes) # pretty Bayesian stuff
library(pander) # for slick tables
library(kableExtra) # for scrolling tables
library(lubridate) # working with times and durations
library(rcartocolor) # for nice colour palettes
library(patchwork) # for creating figures with multiple panels
library(stickylabeller) # for adding annotations to facets

```

$~$

**Pilot experiment: confirming that _SD_ exhibits segregation distortion**

In a pilot experiment, we measured the strength of segregation distortion produced by each of our experimental treatment lines. We crossed females from each of the three _SD/+_ lines and the _+/+_ line to males homozygous for the _bw_ mutation (Figure S1); like _SD_, _bw_ is located on chromosome 2, so this cross yielded _SD/bw_ or _+/bw_ progeny. We then mated 20 _SD/bw_ (or _+/bw_) males from each of the four crosses to _bw/bw_ females, and recorded the eye colour (red or brown) of the resulting female offspring to determine the proportion of offspring fertilised by _SD_- (or +) and _bw_-bearing sperm. Male progeny were not counted because some of them in the reciprocal cross (see below) expressed a white-eye phenotype (due to male hemizygosity and an X-linked mutation of _white_), preventing us from determining which copy of chromosome 2 they inherited. 

_SD_ alleles are commonly associated with viability costs, which might cause underestimation of the strength of segregation distortion. To correct for any such viability costs, we also performed the reciprocal cross ( _SD/+_ females × _bw/bw_ males) and calculated the proportion of offspring inheriting the _SD_ bearing chromosome as above. Because _SD_ does not affect segregation in females, a shortage of adult offspring carrying _SD_ (relative to the 50% Mendelian expectation) indicates reduced survival of _SD_ progeny to adulthood (relative to bw progeny). We calculated the viability-corrected estimate of segregation distortion, _k~c~_, using the formula in [Temin](https://www.ncbi.nlm.nih.gov/pubmed/1906417) (1991, Genetics).

To analyse our results, we fit a binomial model, in which red-eye daughters (i.e. the progeny that inherited the _SD_ or _+_ allele from their _SD/bw_ or _+/bw_ father) were treated as ‘successes’ and the brown-eye daughters as ‘failures’. We included the sex of the experimental individual and the variant of _SD_ (or control) as fixed effects (with the control as the reference level), as well as the interaction between these variables. We also included pair ID as a random effect.

$~$

$~$

$~$

$~$

$~$

**Table S1**: recipe for food medium used in our experiment. The provided quantities make ~ 1 litre of food.

```{r, food recipe}

tibble("Ingredients" = c("Soy flour", "Cornmeal", "Yeast", "Dextrose", "Agar", "Water", "Tegosept", "Acid mix (4 mL orthophosphoric acid, 41 mL propionic acid, 55 mL water to make 100 mL)"),
       "Quantity" = c("20 g", "73 g", "35 g", "75 g", "6 g", "1000 mL", "17 mL", "14 mL")) %>% 
  pander(split.cell = 40, split.table = Inf)

```

```{r fig.width=6, fig.height=8}

img <- readPNG("SD_crossing_scheme.png")
 grid.raster(img)
```
**Figure S1.** Crossing scheme used to standardise the genetic background across the _SD-5/+_, _SD-72/+_, _SD-Mad/+_ and _SD+/+_ lines. The _SD+/+_ line was created in identical fashion except that we substituted the  _SD_ bearing chromosome with chromosome 2 from the _w^1118^_ isogenic line. Note that at step four there are three possible options 1) the leftmost genotype can be backcrossed to maintain it in the laboratory, 2) the leftmost genotype can be crossed to a _bw_ stock to produce the experimental flies used in Experiment 1 or 3) the leftmost genotype can be crossed to _w^1118^_ to create the experimental flies used in Experiments 2 and 3.  

$~$


```{r, include= FALSE}

# load the drive test data and create the total_female column

drive_test_data <- 
  read.csv("data/Drive_test.csv") %>% 
  mutate(total_female = SD.FEMALE + bw.FEMALE) %>%
  as_tibble()

# reorder the factor levels for the SD variable, in ascending order of drive.

drive_test_data$SD <- 
  factor(drive_test_data$SD, levels = c("W1118", "MAD", "72", "5"))

drive_test_data <- 
  drive_test_data %>% 
  mutate(SEX = as.factor(SEX),
         ID = as.factor(ID))

# Load in the data from Experiment 2. Remove unrequired columns, convert durations to a format that R can read, expressed in seconds, and log transform copulation latency.

precop_data <- 
  read.csv("data/two_choice_test_data.csv") %>% 
  select(-c(Mating_start_time, Mating_end_time)) %>% 
  mutate(Enter_time = as.numeric(hms(Enter_time)),
         Copulation_latency = as.numeric(hms(Copulation_latency)),
         Copulation_duration = as.numeric(hms(Copulation_duration)),
         Rearing_vial = as.factor(Rearing_vial)) %>% 
  as_tibble()

# reorder the factor levels for the SD variable, in ascending order of drive 

precop_data$SD <- 
  factor(precop_data$SD, levels = c("W1118", "MAD", "72"))

precop_duration_data <-
  precop_data %>% 
  filter(Successful_male == "SD")

# read in the data from Experiment 3 and remove unrequired columns

data <- 
  read.csv("data/SD_mating_data.csv") %>% 
  select(- c(Start_1, Mating.start_1, Mating.end_1, Start_2, Mating.start_2, Mating.end_2)) %>% 
  as_tibble()

# reorder the factor levels for the SD variable, in ascending order of drive 

data$SD <- 
  factor(data$SD, levels = c("W1118", "MAD", "72", "5"))

# change the mating order variable so that SD is replaced with 'first' and LHM is replaced with 'second'. Then, change the remating column so that 0 = the female remated and 1 = the female did not remate, which can be used for censoring later

data <-
  data %>% 
  mutate(Mating.Order = if_else(Mating.Order == "SD", "first", "second"),
         Censored = ifelse(Remating == "Y", 0, 1),
         Block = as.factor(Block),
         ID = as.factor(ID),
         Vial = as.factor(Vial))

# create sperm comp data

# create the total_offspring column and remove rows where we could not measure GFP progeny/treatment progeny or total offspring. This occurred when the female failed to mate with the 2nd male (hence there was no sperm competition), when a female escaped or died between mating opportunities, and rarely due to a data recording error. When the total number of offspring produced by a female = 0, we were unable to measure sperm competitive ability.

sperm_comp_data <- 
  data %>%
  mutate(total_offspring = GFP.progeny + Treatment.progeny) %>% 
  select(ID, Block, Mating.Order, Vial, SD, Treatment.progeny, GFP.progeny, total_offspring) %>% 
  filter(!is.na(GFP.progeny)) %>% 
  filter(!(total_offspring == 0))
  

# create remating data

# remove NAs corresponding to females that didn't mate in the first mating trial or that escaped or died and only include females that mated with SD males first 

remating_data <-
  data %>% 
  filter(!is.na(Remating),
         Mating.Order == "first") %>%
  select(ID, Block, Mating.Order, Vial, SD, Latency_1, Duration_1, Remating, Latency_2, Duration_2, Censored) %>% 
  # convert into readable minutes
  mutate(Latency_1 = as.numeric(hms(Latency_1)) / 60,
         Duration_1 = as.numeric(hms(Duration_1)) / 60,
         Latency_2 = as.numeric(hms(Latency_2)) / 60,
         Duration_2 = as.numeric(hms(Duration_2)) / 60) %>% 
  # round to whole minutes
  mutate(Latency_1 = round(Latency_1, digits = 0),
         Duration_1 = round(Duration_1, digits = 0),
         Latency_2 = round(Latency_2, digits = 0),
         Duration_2 = round(Duration_2, digits = 0))
```

```{r, include=FALSE}

drive_model <- 
  brm(SD.FEMALE | trials(total_female) ~ SEX * SD + (1|ID),
      data = drive_test_data, 
      family = binomial,
      prior = c(prior(normal(0, 5), class = Intercept), 
                prior(normal(0, 3), class = b)),
      iter = 8000,
      warmup = 2000,
      chains = 4,
      cores = 4,
      seed = 2,
      file = "fits/drive_model")
```

```{r, include=FALSE}

# Define new data for prediction
  
new <-
  expand.grid(total_female = 100, SD = unique(drive_test_data$SD), SEX = unique(drive_test_data$SEX)) %>% 
  mutate(Var1 = 1:8)

# Define new data for prediction with posteriors

new_posterior <-
  expand.grid(total_female = 100, SD = unique(drive_test_data$SD), SEX = unique(drive_test_data$SEX)) %>% 
  mutate(id = paste("V", 1:8, sep = "")) %>% 
  as_tibble()

# Get the summarised predicted means

predictions <- 
  left_join(
    melt(fitted(drive_model, newdata = new, re_formula = NA)) %>% 
      spread(Var2, value), new, by = "Var1") %>% 
  rename(Sex = SEX, `k - the estimated inheritance (%)` = Estimate) %>% 
  select(-c(Var1, total_female)) %>% 
  select(SD, Sex, `k - the estimated inheritance (%)`, Est.Error, Q2.5, Q97.5)

# Now get the predicted posterior

posterior_prediction <- 
  as_tibble(fitted(drive_model, newdata = new_posterior, re_formula = NA, summary = FALSE)) %>% # 8 cols, 8000ish rows
  mutate(posterior_draw = 1:n()) %>%
  tidyr::gather(key = id, value = percent_focal_offspring, -posterior_draw) %>%
  left_join(new_posterior %>% select(-total_female), by = "id") %>%
  select(-id) %>% 
  as_tibble()
```

$~$

```{r}
posterior_prediction %>%
    mutate(SD = recode(posterior_prediction$SD, "MAD" = "SD-Mad", "72" = "SD-72", "5" = "SD-5"),
         SEX = recode(posterior_prediction$SEX, "F" = "Females", "M" = "Males")) %>% 
  
  ggplot(aes(SD, percent_focal_offspring)) + 
  stat_eye(aes(fill = SD), .width = c(0.66, 0.95)) + # width indicates the uncertainty intervals: here we have 66% and 95% intervals
  scale_fill_manual(values = c("W1118" = "#d3f2a3", "SD-Mad" = "#97e196", "SD-72" = "#6cc08b", "SD-5" = "#4c9b82")) +
  geom_hline(yintercept = 50, linetype = 2) +
  facet_wrap( ~ SEX) + 
  scale_y_continuous("Estimated inheritance (%)",
                     breaks = c(40, 50, 60, 70, 80, 90)) +
  xlab("Variant carried (homologous to bw chromosome)") +
  theme_bw() + 
  theme(legend.position = "none",
        panel.grid.minor = element_blank())
```

**Figure S2**: The estimated percentage of female offspring that inherited a _SD_ allele from a heterozygous parent, split by the sex of the parent. Black points indicate the estimated mean with associated 66 and 95% uncertainty intervals, while coloured area shows the posterior distribution. The dotted line indicates 50% inheritance; the expectation in the absence of segregation distortion. 

$~$

$~$

$~$

$~$

$~$

$~$

$~$

$~$

$~$

$~$

$~$

**Table S2**: the viability corrected inheritance (following Temin, 1991) of each _SD_ variant and the control allele from a _SD/+_ (or _+/+_) male.
```{r corrected k values}

post <- posterior_samples(drive_model) %>% 
  as_tibble()

k_c_SD5 <-
  post %>% 
  select(b_Intercept, b_SD5, `b_SEXM:SD5`) %>% 
  mutate(Female_SD_progeny = inv_logit_scaled(b_Intercept + b_SD5) * 100,
         Female_bw_progeny = 100 - Female_SD_progeny,
         W_SD5 = Female_bw_progeny / Female_SD_progeny,
         Male_SD_progeny = inv_logit_scaled(b_Intercept + `b_SEXM:SD5`) * 100,
         Male_bw_progeny = 100 - Male_SD_progeny) %>% 
  select(Male_SD_progeny, Male_bw_progeny, W_SD5) %>% 
  mutate(k_c = Male_SD_progeny / (Male_SD_progeny + (Male_bw_progeny / W_SD5))) %>% 
  summarise(`k corrected for viability costs` = median(k_c),
            `Q2.5%` = quantile(k_c, probs = 0.025),
            `Q97.5%` = quantile(k_c, probs = 0.975)) %>% 
  mutate(`Variant carried` = "SD-5")

  

k_c_SD72 <-
  post %>% 
  select(b_Intercept, b_SD72, `b_SEXM:SD72`) %>% 
  mutate(Female_SD_progeny = inv_logit_scaled(b_Intercept + b_SD72) * 100,
         Female_bw_progeny = 100 - Female_SD_progeny,
         W_SD72 = Female_bw_progeny / Female_SD_progeny,
         Male_SD_progeny = inv_logit_scaled(b_Intercept + `b_SEXM:SD72`) * 100,
         Male_bw_progeny = 100 - Male_SD_progeny) %>% 
  select(Male_SD_progeny, Male_bw_progeny, W_SD72) %>% 
  mutate(k_c = Male_SD_progeny / (Male_SD_progeny + (Male_bw_progeny / W_SD72))) %>% 
  summarise(`k corrected for viability costs` = median(k_c),
            `Q2.5%` = quantile(k_c, probs = 0.025),
            `Q97.5%` = quantile(k_c, probs = 0.975)) %>% 
  mutate(`Variant carried` = "SD-72")


k_c_SDMAD <-
  post %>% 
  select(b_Intercept, b_SDMAD, `b_SEXM:SDMAD`) %>% 
  mutate(Female_SD_progeny = inv_logit_scaled(b_Intercept + b_SDMAD) * 100,
         Female_bw_progeny = 100 - Female_SD_progeny,
         W_SDMAD = Female_bw_progeny / Female_SD_progeny,
         Male_SD_progeny = inv_logit_scaled(b_Intercept + `b_SEXM:SDMAD`) * 100,
         Male_bw_progeny = 100 - Male_SD_progeny) %>% 
  select(Male_SD_progeny, Male_bw_progeny, W_SDMAD) %>% 
  mutate(k_c = Male_SD_progeny / (Male_SD_progeny + (Male_bw_progeny / W_SDMAD))) %>% 
  summarise(`k corrected for viability costs` = median(k_c),
            `Q2.5%` = quantile(k_c, probs = 0.025),
            `Q97.5%` = quantile(k_c, probs = 0.975)) %>% 
  mutate(`Variant carried` = "SD-Mad")


k_c_W1118 <-
  post %>% 
  select(b_Intercept, b_SEXM) %>% 
  mutate(Female_W1118_progeny = inv_logit_scaled(b_Intercept) * 100,
         Female_bw_progeny = 100 - Female_W1118_progeny,
         W_W1118 = Female_bw_progeny / Female_W1118_progeny,
         Male_W1118_progeny = inv_logit_scaled(b_Intercept + b_SEXM) * 100,
         Male_bw_progeny = 100 - Male_W1118_progeny) %>% 
  select(Male_W1118_progeny, Male_bw_progeny, W_W1118) %>% 
  mutate(k_c = Male_W1118_progeny / (Male_W1118_progeny + (Male_bw_progeny / W_W1118))) %>% 
  summarise(`k corrected for viability costs` = median(k_c),
            `Q2.5%` = quantile(k_c, probs = 0.025),
            `Q97.5%` = quantile(k_c, probs = 0.975)) %>% 
  mutate(`Variant carried` = "W1118")


bind_rows(k_c_SD5, k_c_SD72, k_c_SDMAD, k_c_W1118) %>% 
  select(`Variant carried`, everything()) %>% 
  pander(round = 3)

```

```{r, include=FALSE}


# Fit the model

mating_latency_survival_model<- 
  brm(Copulation_latency ~ SD + (1|Rearing_vial),
      data = precop_duration_data,
      prior = c(prior(normal(0, 5), class = Intercept), 
                prior(normal(0, 3), class = b)),
      family = weibull, inits = 0,
      cores = 4, chains = 4, iter = 8000, warmup = 2000,
      control = list(adapt_delta = 0.99, max_treedepth = 10),
      seed = 1, file = "fits/mating_latency_survival_model")

```

```{r Bayes predictions mating latency, include=FALSE}

# Define new data for prediction with posteriors

new_posterior_mating_latency <-
  expand.grid(SD = unique(precop_duration_data$SD)) %>% 
  mutate(id = paste("V", 1:3, sep = "")) %>% 
  as_tibble()
  

# Get predicted means

predictions_mating_latency <- 
  as.data.frame(fitted(mating_latency_survival_model, newdata = new_posterior_mating_latency, re_formula = NA, summary = FALSE)) %>% # 12 cols, 8000ish rows
  mutate(posterior_draw = 1:n()) %>%
  gather(key = id, value = mean_mating_latency, -posterior_draw) %>%
  mutate(mean_mating_latency = mean_mating_latency / 60) %>%
  left_join(new_posterior_mating_latency, by = "id") %>%
  select(-id) %>% 
  as_tibble() %>% 
  group_by(SD) %>% 
  summarise(`Estimated time to mating (mins)` = median(mean_mating_latency),
            `2.5%` = quantile(mean_mating_latency, probs = 0.025),
            `97.5%` = quantile(mean_mating_latency, probs = 0.975))


# Now get the predicted posterior

posterior_prediction_mating_latency <- 
  as.data.frame(fitted(mating_latency_survival_model, newdata = new_posterior_mating_latency, re_formula = NA, summary = FALSE)) %>% # 12 cols, 8000ish rows
  mutate(posterior_draw = 1:n()) %>%
  gather(key = id, value = mean_mating_latency, -posterior_draw) %>%
  mutate(mean_mating_latency = mean_mating_latency / 60) %>% # if we want to express in secs then delete this
  left_join(new_posterior_mating_latency, by = "id") %>%
  select(-id) %>% 
  as_tibble()

```

```{r, include=FALSE}

# get posterior samples

post_ml <- posterior_samples(mating_latency_survival_model) %>% 
  as_tibble()

# now find the differences between the reference level (w1118) and the remaining levels (the SD lines)

# the inv_logit_scaled() function converts the posterior draws onto the response scale 

post_diff_ml <- post_ml %>% 
  mutate(p_w1118 =  exp(b_Intercept),
         p_SD_MAD = exp(b_SDMAD + b_Intercept),
         p_SD_72 = exp(b_SD72 + b_Intercept),
         `SD-Mad` = p_SD_MAD / p_w1118,
         `SD-72` = p_SD_72 / p_w1118) %>% 
  gather(key = `difference comparison`, value = proportion) %>% 
  filter(`difference comparison` == c("SD-Mad", "SD-72"))
  
```

```{r, include=FALSE}
mean_mating_latency_plot <-
  posterior_prediction_mating_latency %>%
  mutate(SD = recode(posterior_prediction_mating_latency$SD, "MAD" = "SD-Mad", "72" = "SD-72", "5" = "SD-5")) %>%
  ggplot(aes(SD, mean_mating_latency)) + 
  stat_halfeye(aes(fill = SD), .width = c(0.66, 0.95)) + # width indicates the uncertainty intervals: here we have 66% and 95% intervals
  scale_fill_manual(values = c("W1118" = "#d3f2a3", "SD-Mad" = "#97e196", "SD-72" = "#6cc08b", "SD-5" = "#4c9b82")) +
  coord_flip(ylim = c(0, 100)) +
  ylab("Estimated time to mating\n (minutes)") +
  xlab("Variant carried by male") +
  theme_bw() + 
  theme(legend.position = "none",
        panel.grid.minor = element_blank())
```

```{r, include=FALSE}

mating_latency_odds <- 
  post_ml %>% 
  mutate(`SD-Mad` = b_SDMAD,
         `SD-72` = b_SD72) %>% 
  gather(key = parameter, value = logodds) %>% 
  filter(parameter == c("SD-Mad", "SD-72")) %>%
  as_tibble() %>% 
  mutate(parameter =factor(parameter, levels=c("SD-Mad", "SD-72"))) %>%
  
  
  ggplot(aes(parameter, logodds)) + 
  stat_halfeye(aes(fill = parameter), .width = c(0.66, 0.95)) + # width indicates the uncertainty intervals: here we have 66% and 95% intervals
  scale_fill_manual(values = c("SD-Mad" = "#97e196", "SD-72" = "#6cc08b", "SD-5" = "#4c9b82")) +
  coord_flip() +
  geom_hline(yintercept = 0, linetype = 2) +
  scale_y_continuous("Odds difference from w1118",
                     breaks = c(-2, -1, 0, 1)) +
  xlab("Variant carried by male") +
  theme_bw() + 
  theme(legend.position = "none",
        panel.grid.minor = element_blank())   

```

$~$

$~$

$~$

$~$

$~$

$~$

$~$

$~$

$~$

$~$

$~$

```{r}
mean_mating_latency_plot /
mating_latency_odds + plot_annotation(tag_levels = "a")
```

**Figure S3:** the mean time required for an _SD/+_ male to start mating with a _LH~m~_ female in Experiment 1, and how this compares to _w^1118^_ control males. Panel **a** shows the estimated mating latency for _SD/+_ and control males. Panel **b** shows effect sizes on the odds scale for the _SD_ variants. Negative values indicate that _SD/+_ males mated faster than _w^1118^_ control males. Black points indicate the estimated mean with associated 66 and 95% uncertainty intervals, while coloured area shows the posterior distribution.

$~$

```{r, include=FALSE}

copulation_duration_survival_model<- 
  brm(Copulation_duration ~ SD + (1|Rearing_vial),
      data = precop_duration_data,
      prior = c(prior(normal(0, 5), class = Intercept), 
                prior(normal(0, 3), class = b)),
      family = weibull, inits = 0,
      cores = 4, chains = 4, iter = 8000, warmup = 2000,
      control = list(adapt_delta = 0.99, max_treedepth = 10),
      seed = 1, file = "fits/copulation_duration_survival_model")

```

```{r Bayes predictions copulation duration, include=FALSE}

# Define new data for prediction with posteriors

new_posterior_copulation_duration <-
  expand.grid(SD = unique(precop_duration_data$SD)) %>% 
  mutate(id = paste("V", 1:3, sep = "")) %>% 
  as_tibble()
  

# Get predicted means

predictions_copulation_duration <- 
  as.data.frame(fitted(copulation_duration_survival_model, newdata = new_posterior_copulation_duration, re_formula = NA, summary = FALSE)) %>% # 12 cols, 8000ish rows
  mutate(posterior_draw = 1:n()) %>%
  gather(key = id, value = mean_copulation_duration, -posterior_draw) %>%
  mutate(mean_copulation_duration = mean_copulation_duration / 60) %>%
  left_join(new_posterior_copulation_duration, by = "id") %>%
  select(-id) %>% 
  as_tibble() %>% 
  group_by(SD) %>% 
  summarise(`Estimated copulation duration (mins)` = median(mean_copulation_duration),
            `2.5%` = quantile(mean_copulation_duration, probs = 0.025),
            `97.5%` = quantile(mean_copulation_duration, probs = 0.975))


# Now get the predicted posterior

posterior_prediction_copulation_duration <- 
  as.data.frame(fitted(copulation_duration_survival_model, newdata = new_posterior_copulation_duration, re_formula = NA, summary = FALSE)) %>% # 12 cols, 8000ish rows
  mutate(posterior_draw = 1:n()) %>%
  gather(key = id, value = mean_copulation_duration, -posterior_draw) %>%
  mutate(mean_copulation_duration = mean_copulation_duration / 60) %>% # if we want to express in secs then delete this
  left_join(new_posterior_copulation_duration, by = "id") %>%
  select(-id) %>% 
  as_tibble()

```

```{r, include=FALSE}

# get posterior samples

post_cd <- posterior_samples(copulation_duration_survival_model) %>% 
  as_tibble()

# now find the differences between the reference level (w1118) and the remaining levels (the SD lines)

# the inv_logit_scaled() function converts the posterior draws onto the response scale 

post_diff_cd <- post_cd %>% 
  mutate(p_w1118 =  exp(b_Intercept),
         p_SD_MAD = exp(b_SDMAD + b_Intercept),
         p_SD_72 = exp(b_SD72 + b_Intercept),
         `SD-Mad` = p_SD_MAD / p_w1118,
         `SD-72` = p_SD_72 / p_w1118) %>% 
  gather(key = `difference comparison`, value = proportion) %>% 
  filter(`difference comparison` == c("SD-Mad", "SD-72"))
  
```

```{r}
mean_copulation_duration_plot <-
  posterior_prediction_copulation_duration %>%
  mutate(SD = recode(posterior_prediction_copulation_duration$SD, "MAD" = "SD-Mad", "72" = "SD-72", "5" = "SD-5")) %>%
  ggplot(aes(SD, mean_copulation_duration)) + 
  stat_halfeye(aes(fill = SD), .width = c(0.66, 0.95)) + # width indicates the uncertainty intervals: here we have 66% and 95% intervals
  scale_fill_manual(values = c("W1118" = "#d3f2a3", "SD-Mad" = "#97e196", "SD-72" = "#6cc08b", "SD-5" = "#4c9b82")) +
  coord_flip(ylim = c(15, 30)) +
  ylab("Estimated copulation duration\n (minutes)") +
  xlab("Variant carried by male") +
  theme_bw() + 
  theme(legend.position = "none",
        panel.grid.minor = element_blank())
```

```{r}

copulation_duration_odds <- 
  post_cd %>% 
  mutate(`SD-Mad` = b_SDMAD,
         `SD-72` = b_SD72) %>% 
  gather(key = parameter, value = odds) %>% 
  filter(parameter == c("SD-Mad", "SD-72")) %>%
  as_tibble() %>% 
  mutate(parameter =factor(parameter, levels=c("SD-Mad", "SD-72"))) %>%
  
  
  ggplot(aes(parameter, odds)) + 
  stat_halfeye(aes(fill = parameter), .width = c(0.66, 0.95)) + # width indicates the uncertainty intervals: here we have 66% and 95% intervals
  scale_fill_manual(values = c("SD-Mad" = "#97e196", "SD-72" = "#6cc08b", "SD-5" = "#4c9b82")) +
  coord_flip() +
  geom_hline(yintercept = 0, linetype = 2) +
  scale_y_continuous("Odds difference from w1118",
                     breaks = c(-0.25, 0, 0.25)) +
  xlab("Variant carried by male") +
  theme_bw() + 
  theme(legend.position = "none",
        panel.grid.minor = element_blank())   

```

```{r}
mean_copulation_duration_plot /
(copulation_duration_odds) + plot_annotation(tag_levels = "a")
```

**Figure S4:** no difference in the duration of mating between a _SD/+_ male and a _LH~m~_ female in Experiment 1, compared to _w^1118^_ control males. Panel **a** shows the estimated copulation duration for _SD/+_ and control males. Panel **b** shows effect sizes on the odds scale for the _SD_ variants. Positive values indicate that _SD/+_ males mated for longer than _w^1118^_ control males. Black points indicate the estimated mean with associated 66 and 95% uncertainty intervals, while coloured area shows the posterior distribution.

$~$

```{r}


# Fit the model with right censoring

remating_survival_model_censored <- 
  brm(Latency_2 | cens(Censored) ~ SD + Block + (1|Rearing_vial),
      data = remating_data,
      prior = c(prior(normal(0, 5), class = Intercept), 
                prior(normal(0, 3), class = b)),
      family = weibull, inits = 0,
      cores = 4, chains = 4, iter = 8000, warmup = 2000,
      control = list(adapt_delta = 0.95, max_treedepth = 10),
      seed = 1, file = "fits/remating_survival_model_censored")

```

```{r Bayes predictions remating latency}

# Define new data for prediction with posteriors

new_posterior_remating_latency <-
  expand.grid(SD = unique(remating_data$SD), Block = unique(remating_data$Block)) %>% 
  mutate(id = paste("V", 1:12, sep = "")) %>% 
  as_tibble()
  

# Get predicted means

predictions_remating_latency <- 
  as.data.frame(fitted(remating_survival_model_censored, newdata = new_posterior_remating_latency, re_formula = NA, summary = FALSE)) %>% # 12 cols, 8000ish rows
  mutate(posterior_draw = 1:n()) %>%
  gather(key = id, value = avg_remating_latency, -posterior_draw) %>%
  left_join(new_posterior_remating_latency, by = "id") %>%
  select(-id) %>% 
  as_tibble() %>% 
  group_by(SD, Block) %>% 
  summarise(`Estimated time to remating (mins)` = median(avg_remating_latency) / 60,
            `2.5%` = quantile(avg_remating_latency, probs = 0.025) / 60,
            `97.5%` = quantile(avg_remating_latency, probs = 0.975) / 60)


# Now get the predicted posterior

posterior_prediction_remating_latency <- 
  as.data.frame(fitted(remating_survival_model_censored, newdata = new_posterior_remating_latency, re_formula = NA, summary = FALSE)) %>% # 12 cols, 8000ish rows
  mutate(posterior_draw = 1:n()) %>%
  gather(key = id, value = avg_remating_latency, -posterior_draw) %>%
  left_join(new_posterior_remating_latency, by = "id") %>%
  mutate(avg_remating_latency = avg_remating_latency / 60) %>% 
  select(-id) %>% 
  as_tibble()

```

```{r}

# get posterior samples

post_l <- posterior_samples(remating_survival_model_censored) %>% 
  as_tibble()

# now find the differences between the reference level (w1118) and the remaining levels (the SD lines)

# the inv_logit_scaled() function converts the posterior draws onto the response scale 

post_diff_l <- post_l %>% 
  mutate(p_w1118 =  exp(b_Intercept),
         p_SD_MAD = exp(b_SDMAD + b_Intercept),
         p_SD_72 = exp(b_SD72 + b_Intercept),
         p_SD_5 = exp(b_SD5 + b_Intercept),
         `SD-Mad` = p_SD_MAD / p_w1118,
         `SD-72` = p_SD_72 / p_w1118,
         `SD-5` = p_SD_5 / p_w1118) %>% 
  gather(key = `difference comparison`, value = proportion) %>% 
  filter(`difference comparison` == c("SD-Mad", "SD-72", "SD-5"))
  
```

```{r}
mean_latency_plot <-
  posterior_prediction_remating_latency %>%
  mutate(SD = recode(posterior_prediction_remating_latency$SD, "MAD" = "SD-Mad", "72" = "SD-72", "5" = "SD-5")) %>%
  filter(Block == "1") %>% 
  ggplot(aes(SD, avg_remating_latency)) + 
  stat_halfeye(aes(fill = SD), .width = c(0.66, 0.95)) + # width indicates the uncertainty intervals: here we have 66% and 95% intervals
  scale_fill_manual(values = c("W1118" = "#d3f2a3", "SD-Mad" = "#97e196", "SD-72" = "#6cc08b", "SD-5" = "#4c9b82")) +
  coord_flip(ylim = c(0, 250)) +
  ylab("Estimated time to remating\n (minutes)") +
  xlab("Variant mated to first") +
  theme_bw() + 
  theme(legend.position = "none",
        panel.grid.minor = element_blank())
```

```{r}

latency_odds <- 
  post_l %>% 
  mutate(`SD-Mad` = b_SDMAD,
         `SD-72` = b_SD72,
         `SD-5` = b_SD5) %>% 
  gather(key = parameter, value = logodds) %>% 
  filter(parameter == c("SD-Mad", "SD-72", "SD-5")) %>%
  as_tibble() %>% 
  mutate(parameter =factor(parameter, levels=c("SD-Mad", "SD-72", "SD-5"))) %>%
  
  
  ggplot(aes(parameter, logodds)) + 
  stat_halfeye(aes(fill = parameter), .width = c(0.66, 0.95)) + # width indicates the uncertainty intervals: here we have 66% and 95% intervals
  scale_fill_manual(values = c("SD-Mad" = "#97e196", "SD-72" = "#6cc08b", "SD-5" = "#4c9b82")) +
  coord_flip() +
  geom_hline(yintercept = 0, linetype = 2) +
  scale_y_continuous("Odds difference from w1118",
                     breaks = c(-2, -1, 0, 1)) +
  xlab("Variant mated to first") +
  theme_bw() + 
  theme(legend.position = "none",
        panel.grid.minor = element_blank())   

```

$~$

```{r}
mean_latency_plot /
(latency_odds) + plot_annotation(tag_levels = "a")
```

**Figure S5:** the effect that _SD/+_ males had on female remating latency in Experiment 2, and how this compares to _w^1118^_ control males. Panel **a** shows the estimated remating latency for females exposed to _LH~m~^UBI^_ males over a three-hour period, that had mated with a _SD/+_ or control male four days earlier. Panel **b** shows effect sizes on the odds scale for the _SD_ variants. Negative values indicate that the mates of _SD/+_ males remated faster than the mates of _w^1118^_ control males. Black points indicate the estimated mean with associated 66 and 95% uncertainty intervals, while coloured area shows the posterior distribution.

$~$

```{r}

# Filter so that only trials where the SD male mated with the female second are included

copulation_data_1 <- 
  sperm_comp_data %>%
  filter(Mating.Order == "first") 

copulation_duration_survival_model_1 <- 
  brm(Duration_1 ~ SD + Block + (1|Rearing_vial),
      data = copulation_data_1,
      prior = c(prior(normal(0, 5), class = Intercept), 
                prior(normal(0, 3), class = b)),
      family = weibull, inits = 0,
      cores = 4, chains = 4, iter = 8000, warmup = 2000,
      control = list(adapt_delta = 0.99, max_treedepth = 10),
      seed = 1, file = "fits/copulation_duration_survival_model_1")

```

```{r}
# Define new data for prediction with posteriors

new_posterior_copulation_duration_1 <-
  expand.grid(SD = unique(copulation_data_1$SD), Block = unique(copulation_data_1$Block)) %>% 
  mutate(id = paste("V", 1:12, sep = "")) %>% 
  as_tibble()

# Get predicted means

predictions_copulation_duration_1 <- 
  as.data.frame(fitted(copulation_duration_survival_model_1, newdata = new_posterior_copulation_duration_1, re_formula = NA, summary = FALSE)) %>% # 12 cols, 8000ish rows
  mutate(posterior_draw = 1:n()) %>%
  gather(key = id, value = mean_copulation_duration, -posterior_draw) %>%
  mutate(mean_copulation_duration = mean_copulation_duration / 60) %>%
  left_join(new_posterior_copulation_duration_1, by = "id") %>%
  select(-id) %>% 
  as_tibble() %>% 
  group_by(SD) %>% 
  summarise(`Estimated copulation duration (mins)` = median(mean_copulation_duration),
            `2.5%` = quantile(mean_copulation_duration, probs = 0.025),
            `97.5%` = quantile(mean_copulation_duration, probs = 0.975))


# Now get the predicted posterior

posterior_prediction_copulation_duration_1 <- 
  as.data.frame(fitted(copulation_duration_survival_model_1, newdata = new_posterior_copulation_duration_1, re_formula = NA, summary = FALSE)) %>% # 12 cols, 8000ish rows
  mutate(posterior_draw = 1:n()) %>%
  gather(key = id, value = mean_copulation_duration, -posterior_draw) %>%
  mutate(mean_copulation_duration = mean_copulation_duration / 60) %>% # if we want to express in secs then delete this
  left_join(new_posterior_copulation_duration_1, by = "id") %>%
  select(-id) %>% 
  as_tibble()
```

```{r}
# get posterior samples

post_cd_1 <- posterior_samples(copulation_duration_survival_model_1) %>% 
  as_tibble()

# now find the differences between the reference level (w1118) and the remaining levels (the SD lines)

# the exp() function converts the posterior draws onto the response scale 

post_diff_cd_1 <- post_cd_1 %>% 
  mutate(p_w1118 =  exp(b_Intercept),
         p_SD_MAD = exp(b_SDMAD + b_Intercept),
         p_SD_72 = exp(b_SD72 + b_Intercept),
         p_SD_5 = exp(b_SD5 + b_Intercept),
         `SD-Mad` = p_SD_MAD / p_w1118,
         `SD-72` = p_SD_72 / p_w1118,
         `SD-5` = p_SD_5 / p_w1118) %>% 
  gather(key = `difference comparison`, value = proportion) %>% 
  filter(`difference comparison` == c("SD-Mad", "SD-72", "SD-5"))
```

```{r}
mean_copulation_duration_plot_1 <-
  posterior_prediction_copulation_duration_1 %>%
  mutate(SD = recode(posterior_prediction_copulation_duration_1$SD, "MAD" = "SD-Mad", "72" = "SD-72", "5" = "SD-5")) %>%
  ggplot(aes(SD, mean_copulation_duration)) + 
  stat_halfeye(aes(fill = SD), .width = c(0.66, 0.95)) + # width indicates the uncertainty intervals: here we have 66% and 95% intervals
  scale_fill_manual(values = c("W1118" = "#d3f2a3", "SD-Mad" = "#97e196", "SD-72" = "#6cc08b", "SD-5" = "#4c9b82")) +
  coord_flip(ylim = c(10, 35)) +
  ylab("Estimated copulation duration in\nfirst mating role (minutes)") +
  xlab("Variant carried by male") +
  theme_bw() + 
  theme(legend.position = "none",
        panel.grid.minor = element_blank())
```

```{r}
copulation_duration_odds_1 <- 
  post_cd_1 %>% 
  mutate(`SD-Mad` = b_SDMAD,
         `SD-72` = b_SD72,
         `SD-5` = b_SD5) %>% 
  gather(key = parameter, value = odds) %>% 
  filter(parameter == c("SD-Mad", "SD-72", "SD-5")) %>%
  as_tibble() %>% 
  mutate(parameter =factor(parameter, levels=c("SD-Mad", "SD-72", "SD-5"))) %>%
  
  
  ggplot(aes(parameter, odds)) + 
  stat_halfeye(aes(fill = parameter), .width = c(0.66, 0.95)) + # width indicates the uncertainty intervals: here we have 66% and 95% intervals
  scale_fill_manual(values = c("SD-Mad" = "#97e196", "SD-72" = "#6cc08b", "SD-5" = "#4c9b82")) +
  coord_flip() +
  geom_hline(yintercept = 0, linetype = 2) +
  scale_y_continuous("Odds difference from w1118",
                     breaks = c(-0.25, 0, 0.25, 0.5)) +
  xlab("Variant carried by male") +
  theme_bw() + 
  theme(legend.position = "none",
        panel.grid.minor = element_blank())  
```

```{r}
mean_copulation_duration_plot_1 /
(copulation_duration_odds_1) + plot_annotation(tag_levels = "a")
```

**Figure S6**: no difference in the duration of mating between a _SD/+_ male and a _LH~m~_ female in Experiment 2, compared to _w^1118^_ control males, when the _SD/+_ (or control) male mated first. Panel **a** shows the estimated copulation duration for _SD/+_ and control males. Panel **b** shows effect sizes on the odds scale for the _SD_-variants. Positive values indicate that _SD/+_ males mated for longer than _w^1118^_ control males. Black points indicate the estimated mean with associated 66 and 95% uncertainty intervals, while coloured area shows the posterior distribution.

$~$

```{r}

# Filter so that only trials where the SD male mated with the female second are included

copulation_data_2 <- 
  sperm_comp_data %>%
  filter(Mating.Order == "second") 

copulation_duration_survival_model_2 <- 
  brm(Duration_2 ~ SD + Block + (1|Rearing_vial),
      data = copulation_data_2,
      prior = c(prior(normal(0, 5), class = Intercept), 
                prior(normal(0, 3), class = b)),
      family = weibull, inits = 0,
      cores = 4, chains = 4, iter = 8000, warmup = 2000,
      control = list(adapt_delta = 0.99, max_treedepth = 10),
      seed = 1, file = "fits/copulation_duration_survival_model_2")

```

```{r}
# Define new data for prediction with posteriors

new_posterior_copulation_duration_2 <-
  expand.grid(SD = unique(copulation_data_2$SD), Block = unique(copulation_data_2$Block)) %>% 
  mutate(id = paste("V", 1:12, sep = "")) %>% 
  as_tibble()

# Get predicted means

predictions_copulation_duration_2 <- 
  as.data.frame(fitted(copulation_duration_survival_model_2, newdata = new_posterior_copulation_duration_2, re_formula = NA, summary = FALSE)) %>% # 12 cols, 8000ish rows
  mutate(posterior_draw = 1:n()) %>%
  gather(key = id, value = mean_copulation_duration, -posterior_draw) %>%
  mutate(mean_copulation_duration = mean_copulation_duration / 60) %>%
  left_join(new_posterior_copulation_duration_2, by = "id") %>%
  select(-id) %>% 
  as_tibble() %>% 
  group_by(SD) %>% 
  summarise(`Estimated copulation duration (mins)` = median(mean_copulation_duration),
            `2.5%` = quantile(mean_copulation_duration, probs = 0.025),
            `97.5%` = quantile(mean_copulation_duration, probs = 0.975))


# Now get the predicted posterior

posterior_prediction_copulation_duration_2 <- 
  as.data.frame(fitted(copulation_duration_survival_model_2, newdata = new_posterior_copulation_duration_2, re_formula = NA, summary = FALSE)) %>% # 12 cols, 8000ish rows
  mutate(posterior_draw = 1:n()) %>%
  gather(key = id, value = mean_copulation_duration, -posterior_draw) %>%
  mutate(mean_copulation_duration = mean_copulation_duration / 60) %>% # if we want to express in secs then delete this
  left_join(new_posterior_copulation_duration_2, by = "id") %>%
  select(-id) %>% 
  as_tibble()
```

```{r}
# get posterior samples

post_cd_2 <- posterior_samples(copulation_duration_survival_model_2) %>% 
  as_tibble()

# now find the differences between the reference level (w1118) and the remaining levels (the SD lines)

# the exp() function converts the posterior draws onto the response scale 

post_diff_cd_2 <- post_cd_2 %>% 
  mutate(p_w1118 =  exp(b_Intercept),
         p_SD_MAD = exp(b_SDMAD + b_Intercept),
         p_SD_72 = exp(b_SD72 + b_Intercept),
         p_SD_5 = exp(b_SD5 + b_Intercept),
         `SD-Mad` = p_SD_MAD / p_w1118,
         `SD-72` = p_SD_72 / p_w1118,
         `SD-5` = p_SD_5 / p_w1118) %>% 
  gather(key = `difference comparison`, value = proportion) %>% 
  filter(`difference comparison` == c("SD-Mad", "SD-72", "SD-5"))
```

```{r}
mean_copulation_duration_plot_2 <-
  posterior_prediction_copulation_duration_2 %>%
  mutate(SD = recode(posterior_prediction_copulation_duration_2$SD, "MAD" = "SD-Mad", "72" = "SD-72", "5" = "SD-5")) %>%
  ggplot(aes(SD, mean_copulation_duration)) + 
  stat_halfeye(aes(fill = SD), .width = c(0.66, 0.95)) + # width indicates the uncertainty intervals: here we have 66% and 95% intervals
  scale_fill_manual(values = c("W1118" = "#d3f2a3", "SD-Mad" = "#97e196", "SD-72" = "#6cc08b", "SD-5" = "#4c9b82")) +
  coord_flip(ylim = c(10, 35)) +
  ylab("Estimated copulation duration in\nsecond mating role (minutes)") +
  xlab("Variant carried by male") +
  theme_bw() + 
  theme(legend.position = "none",
        panel.grid.minor = element_blank())
```

```{r}
copulation_duration_odds_2 <- 
  post_cd_2 %>% 
  mutate(`SD-Mad` = b_SDMAD,
         `SD-72` = b_SD72,
         `SD-5` = b_SD5) %>% 
  gather(key = parameter, value = odds) %>% 
  filter(parameter == c("SD-Mad", "SD-72", "SD-5")) %>%
  as_tibble() %>% 
  mutate(parameter =factor(parameter, levels=c("SD-Mad", "SD-72", "SD-5"))) %>%
  
  
  ggplot(aes(parameter, odds)) + 
  stat_halfeye(aes(fill = parameter), .width = c(0.66, 0.95)) + # width indicates the uncertainty intervals: here we have 66% and 95% intervals
  scale_fill_manual(values = c("SD-Mad" = "#97e196", "SD-72" = "#6cc08b", "SD-5" = "#4c9b82")) +
  coord_flip() +
  geom_hline(yintercept = 0, linetype = 2) +
  scale_y_continuous("Odds difference from w1118",
                     breaks = c(-0.25, 0, 0.25, 0.5)) +
  xlab("Variant carried by male") +
  theme_bw() + 
  theme(legend.position = "none",
        panel.grid.minor = element_blank())  
```

```{r}
mean_copulation_duration_plot_2 /
(copulation_duration_odds_2) + plot_annotation(tag_levels = "a")
```

**Figure S7**: mating duration between a _SD/+_ male and a _LH~m~_ female pair in Experiment 2, compared to _w^1118^_ control males, when the _SD/+_ (or control) male mated second. Panel **a** shows the estimated copulation duration for _SD/+_ and control males. Panel **b** shows effect sizes on the odds scale for the _SD_ variants. Positive values indicate that _SD/+_ males mated for longer than _w^1118^_ control males. Black points indicate the estimated mean with associated 66 and 95% uncertainty intervals, while coloured area shows the posterior distribution.

$~$

```{r Enter estimated parameter values}

# k_c values

estimated_k_SD5 <- 0.944 # 94.4% of progeny inherit SD 

estimated_k_SD72 <- 0.909 # 90.9% of progeny inherit SD 

estimated_k_SDMAD <- 0.868 # 86.8% of progeny inherit SD

# The relative mating success for each SD variant

estimated_precop_SD5 <- NA # not measured 

estimated_precop_SD72 <- 1.24
  
estimated_precop_SDMAD <- 1.19

# P1cost and P2cost values, plugged in from Table S7b and Table S8b

P1_SD5 <- 1 - 0.15 

P2_SD5 <- 1 - 0.945 

P1_SD72 <- 1 - 0.43 

P2_SD72 <- 1 - 0.997 

P1_SDMAD <- 1 - 0.39 

P2_SDMAD <- 0 # no cost

# We also include 95% credible intervals for P1 and P2 cost, to use in Figure 2 and Figure S8

lower_P1_SD5 <- 1 - 0.02 

lower_P2_SD5 <- 1 - 0.855

lower_P1_SD72 <- 1 - 0.05 

lower_P2_SD72 <- 1 - 0.969 

lower_P1_SDMAD <-  NA #1 - 0.04 essentially identical to SD-72 so to avoid clutter in our figures we don't include this value

lower_P2_SDMAD <- 0 # no cost

upper_P1_SD5 <- 1 - 0.6

upper_P2_SD5 <- 1 - 0.997

upper_P1_SD72 <- 0 # no cost

upper_P2_SD72 <- 0 # no cost

upper_P1_SDMAD <- 0 # no cost

upper_P2_SDMAD <- 0 # no cost

# Remating probabilities from Table S9a, using estimates from Block 1

estimated_prob_remating_W = 0.304 

estimated_prob_remating_SD5 = 0.755 

estimated_prob_remating_SD72 = 0.425 

estimated_prob_remating_SDMAD = 0.429

# Create a tibble containing empirical estimates

empirical_estimates <-
  tibble(SD = c("SD-5", "SD-72", "SD-MAD"),
         kc = c(estimated_k_SD5, estimated_k_SD72, estimated_k_SDMAD),
         Precop = c(estimated_precop_SD5, estimated_precop_SD72, estimated_precop_SDMAD),
         P1cost = c(P1_SD5, P1_SD72, P1_SDMAD),
         lower_P1cost = c(lower_P1_SD5, lower_P1_SD72, lower_P1_SDMAD),
         upper_P1cost = c(upper_P1_SD5, upper_P1_SD72, upper_P1_SDMAD),
         P2cost = c(P2_SD5, P2_SD72, P2_SDMAD),
         lower_P2cost = c(lower_P2_SD5, lower_P2_SD72, lower_P2_SDMAD),
         upper_P2cost = c(upper_P2_SD5, upper_P2_SD72, upper_P2_SDMAD),
         remating_prob = c(estimated_prob_remating_SD5, estimated_prob_remating_SD72, estimated_prob_remating_SDMAD))


egg_adult_viability_WSD_female <- 1

egg_adult_viability_SDSD_female <- 0

egg_adult_viability_WSD_male <- 1

egg_adult_viability_SDSD_male <- 0

```

```{r}

calc_prop_SD <- function(pop){
  0.5 * sum(pop$prop[str_detect(pop$type, "WSD")]) + sum(pop$prop[str_detect(pop$type, "SDSD")])
}


if(!file.exists("simulation_results/output.rds")){
  output_combined <- c(output1, output2, output3, output4, output5, output6,
                       output7, output8, output9, output10, output11, output12,
                       output13, output14, output15, output16, output17, output18,
                       output19, output20, output21, output22, output23, output24,
                       output25, output26, output27, output28, output29, output30,
                       output31, output32, output33)
  saveRDS(output_combined, "simulation_results/output.rds")
} else{
  output <- readRDS("simulation_results/output.rds")
}



final_SD_props_among_preselection_zygotes <- sapply(output, calc_prop_SD)

final_SD_props_among_adults <- sapply(output, function(pop){
  
  pop$prop <- pop$prop * pop$egg_adult_viability # apply selection, then calculate allele freq of SD
  pop$prop <- pop$prop / sum(pop$prop) 
  calc_prop_SD(pop)
  
})
```

```{r fig.height = 10, fig.width = 10, eval=TRUE}

# make the initial pop


initial_freq_SD <- 0.01

resolution <- 25

gen <- 1000


# updated with latest parameters

parameters <- rbind(
  expand_grid(
    generations = gen,
    k = c(estimated_k_SD5, estimated_k_SD72, estimated_k_SDMAD),
    normalP1 = c(0.1, 0.5),
    P1cost = seq(0, 1, length = resolution),
    P2cost = seq(0, 1, length = resolution),
    prob_remating_W = estimated_prob_remating_W,
    prob_remating_SD = c(estimated_prob_remating_W, estimated_prob_remating_SD72, estimated_prob_remating_SD5),
    egg_adult_viability_WSD_female = egg_adult_viability_WSD_female,
    egg_adult_viability_SDSD_female = egg_adult_viability_SDSD_female,
    egg_adult_viability_WSD_male = egg_adult_viability_WSD_male,
    egg_adult_viability_SDSD_male = egg_adult_viability_SDSD_male,
    S_precop_WSD_male = c(0.8, 1, 1.2),
    initial_freq_SD = initial_freq_SD)
) %>% mutate(parameter_space_ID = row_number())


# Combine the SD frequencies with the parameter data and transform data to improve clarity

plotting_data <- parameters %>%
  mutate(prop_SD = final_SD_props_among_adults,
         P1_actual = (normalP1 -  P1cost * normalP1) * 100,
         P2_actual = ((1 - normalP1) - P2cost * (1 - normalP1)) * 100,
         remating_ratio = prob_remating_SD / prob_remating_W) %>% 
  mutate(remating_ratio = round(remating_ratio, digits = 1))


# Transform our empirical estimates to match the plotting data  

empirical_estimates_0.5 <-
  empirical_estimates %>% 
  mutate(W_remating_prob = 0.30,
         normalP1 = 0.5,
         P1_actual = (normalP1 -  P1cost * normalP1) * 100,
         lower_P1_actual = (normalP1 -  lower_P1cost * normalP1) * 100,
         upper_P1_actual = (normalP1 -  upper_P1cost * normalP1) * 100,
         P2_actual = ((1 - normalP1) - P2cost * (1 - normalP1)) * 100,
         lower_P2_actual = ((1 - normalP1) - lower_P2cost * (1 - normalP1)) * 100,
         upper_P2_actual = ((1 - normalP1) - upper_P2cost * (1 - normalP1)) * 100,
         remating_ratio = remating_prob / estimated_prob_remating_W) %>% 
  mutate(remating_ratio = round(remating_ratio, digits = 1))

# Make Figure S8

(p2 <-
  plotting_data %>% 
  rename(`Wildtype P1` = normalP1,
         `Relative risk of sperm competition` = remating_ratio,
         `Relative mating success` = S_precop_WSD_male) %>% 
  filter(k == 0.944, `Wildtype P1` == 0.5) %>% 
 ggplot(aes(x = P1_actual, y = P2_actual)) +
    geom_blank() +
    geom_raster(aes(fill = 100 * prop_SD)) + 
    stat_contour(aes(z = 100 * prop_SD), colour = "black", binwidth = 10) +
    stat_contour(aes(z = 100 * prop_SD), colour = "black", breaks = 8, linetype = 2) +
    geom_errorbar(data = empirical_estimates_0.5,
                  aes(x = P1_actual, ymin = lower_P2_actual, ymax = upper_P2_actual),
                  width = 2, colour = "grey11", alpha = 0.8) +
    geom_errorbarh(data = empirical_estimates_0.5,
                   aes(y = P2_actual, xmin = lower_P1_actual, xmax = upper_P1_actual),
                   colour = "grey11", alpha = 0.8, height = 2) +
    geom_point(data = empirical_estimates_0.5,
               aes(x = P1_actual, y = P2_actual), 
               pch = 21, fill = "#eb7f86", colour = "grey11", size = 3) +
    facet_wrap(`Relative risk of sperm competition` ~ `Relative mating success`, 
               scales = "free", nrow = 3, strip.position = c("top"),
               labeller = label_glue('({.l}) Relative risk of sperm competition: {`Relative risk of sperm competition`}\nRelative mating success: {`Relative mating success`}')) +
    #annotate("text", label = c("italic(SD-5)", "italic(SD-Mad)", "italic(SD-72)"),
    #x = c(1.5, 3, 5.2), y = c(80, 90, 88), size = 5, colour = "black", parse = TRUE) +
    labs(x = "% offspring sired by SD/+ male in the first mating role (P1)",
         y = "% offspring sired by SD/+ male in the second mating role (P2)") +
    scale_fill_carto_c(type = "sequential", palette = "BluYl", direction = 1, name = "% SD at equilibrium") +
    scale_x_continuous(expand = c(0, 0)) + 
    scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +
    theme(panel.border = element_rect(fill = NA, colour = "black", size = .8),
          strip.background = element_rect(colour = "black", fill = "Aliceblue", size = .8))
)
```

**Figure S8**: Predicted equilibrium frequency of the _SD_ allele, calculated from the population genetic model. The plot depicts the interaction between the P1 (x-axis) and P2 (y-axis) costs suffered by _SD/+_ males in their effects on the equilibrium frequency of _SD_ (shown by the colour scale and 10% contour lines). The dashed line shows an equilibrium frequency of 8%, the upper estimate for _SD_ alleles in natural populations. The plot is split into nine panels, with varying levels of _SD/+_ male mating success across the rows and increasing likelihoods of a female remating after first mating to an _SD/+_ male, $p_{SD/+}$, down the columns. The three orange points (with associated 95% credible intervals) in each panel represent males carrying the _SD-5_ (leftmost point), and _SD-72_ and _SD-Mad_ (rightmost points) alleles; these points show where males carrying these alleles fall in the figure’s parameter space, as measured in Experiment 2. In the parameter space presented here, $k$ = 0.944 (our highest estimated value), $P1_{normal}$ = 0.5, _SD_ homozygotes are non-viable and _SD_ heterozygotes suffer no fitness costs outside of mating success and sperm competition.
